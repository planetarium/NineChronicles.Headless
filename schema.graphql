schema {
  query: StandaloneQuery
  mutation: StandaloneMutation
  subscription: StandaloneSubscription
}

"""
Represents a raw account state.  This is meant to represent a raw storage state void of any application layer context and/or logic.  In particular, this does not deal with currency or fungible asset value directly, which requires additional information on currency such as its ticker and possible minters, etc. while interpreting the data retrieved with the provided contextual information. The same is true for validator sets.
"""
type AccountState {
  """Balance at given address and currency hash pair."""
  balance(
    """The address to look up."""
    address: Address!

    """The currency hash to look up."""
    currencyHash: HashDigestSHA1!
  ): IValue @deprecated(reason: "Does not work post block protocol version 7.")

  """Balances at given addresses and currency hash pair."""
  balances(
    """The list of addresses to look up."""
    addresses: [Address!]!

    """The currency hash to look up."""
    currencyHash: HashDigestSHA1!
  ): [IValue]! @deprecated(reason: "Does not work post block protocol version 7.")

  """The state at given address."""
  state(
    """The address to look up."""
    address: Address!
  ): IValue

  """The state root hash associated with this account state."""
  stateRootHash: HashDigestSHA256!

  """The states at given addresses."""
  states(
    """The list of addresses to look up."""
    addresses: [Address!]!
  ): [IValue]!

  """Total supply in circulation, if recorded, for given currency hash."""
  totalSupply(
    """The currency hash to look up."""
    currencyHash: HashDigestSHA1!
  ): IValue @deprecated(reason: "Does not work post block protocol version 7.")

  """The validator set."""
  validatorSet: IValue @deprecated(reason: "Does not work post block protocol version 6.")
}

type Action {
  """A readable representation for debugging."""
  inspection: String!

  """A JSON representation of action data"""
  json: String!

  """Raw Action data ('hex' or 'base64' encoding available.)"""
  raw(encode: String = "hex"): String!
}

type ActionMutation {
  """Charge Action Points using Material."""
  chargeActionPoint(
    """Avatar to use potion."""
    avatarAddress: Address!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Combine new Consumable."""
  combinationConsumable(
    """Avatar address to combine consumable."""
    avatarAddress: Address!

    """ConsumableRecipe ID from ConsumableRecipeSheet."""
    recipeId: Int!

    """The empty combination slot index to combine consumable. 0 ~ 3"""
    slotIndex: Int!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Combine new equipment."""
  combinationEquipment(
    """Avatar address to create equipment."""
    avatarAddress: Address!

    """EquipmentRecipe ID from EquipmentRecipeSheet."""
    recipeId: Int!

    """The empty combination slot index to combine equipment. 0 ~ 3"""
    slotIndex: Int!

    """EquipmentSubRecipe ID from EquipmentSubRecipeSheet."""
    subRecipeId: Int
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Create new avatar."""
  createAvatar(
    """The index of character slot. 0 ~ 2"""
    avatarIndex: Int!

    """Avatar name."""
    avatarName: String!

    """The index of character ear color. 0 ~ 8"""
    earIndex: Int!

    """The index of character hair color. 0 ~ 8"""
    hairIndex: Int!

    """The index of character eye color. 0 ~ 8"""
    lensIndex: Int!

    """The index of character tail color. 0 ~ 8"""
    tailIndex: Int!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Get daily reward."""
  dailyReward(
    """Avatar address to receive reward."""
    avatarAddress: Address!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Start stage to get material."""
  hackAndSlash(
    """Avatar address."""
    avatarAddress: Address!

    """List of consumable id for use."""
    consumableIds: [Guid]

    """List of costume id for equip."""
    costumeIds: [Guid]

    """List of equipment id for equip."""
    equipmentIds: [Guid]

    """List of rune slot info for equip."""
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    """Stage ID."""
    stageId: Int!

    """World ID containing the stage ID."""
    worldId: Int!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")

  """Upgrade equipment."""
  itemEnhancement(
    """Avatar address to upgrade equipment."""
    avatarAddress: Address!

    """Equipment Guid for upgrade."""
    itemId: Guid!

    """Material Guids for equipment upgrade."""
    materialIds: [Guid!]!

    """The empty combination slot index to upgrade equipment. 0 ~ 3"""
    slotIndex: Int!
  ): TxId! @deprecated(reason: "This API is insecure and must not be used.")
}

type ActionQuery {
  approvePledge(patronAddress: Address!): ByteString!
  auraSummon(
    """Avatar address to get summoned items"""
    avatarAddress: Address!

    """Summon group id"""
    groupId: Int!

    """Count to summon. Must between 1 and 10."""
    summonCount: Int!
  ): ByteString!
  claimItems(
    """List of pair of avatar address, List<FAV> to claim."""
    claimData: [ClaimDataInputType!]!

    """Memo to attach to this action."""
    memo: String
  ): ByteString!
  claimRaidReward(
    """address of avatar state to receive reward."""
    avatarAddress: Address!
  ): ByteString!
  claimStakeReward(
    """The avatar address to receive staking rewards."""
    avatarAddress: Address
  ): ByteString
  claimWorldBossKillReward(
    """address of avatar state to receive reward."""
    avatarAddress: Address!
  ): ByteString!
  combinationConsumable(
    """Avatar address to combine consumable"""
    avatarAddress: Address!

    """Recipe ID to combine consumable"""
    recipeId: Int!

    """Slot index to combine"""
    slotIndex: Int!
  ): ByteString!
  combinationEquipment(
    """Avatar address to combine equipment"""
    avatarAddress: Address!

    """Pay crystal co combine equipment?"""
    payByCrystal: Boolean

    """Combination recipe ID"""
    recipeId: Int!

    """Slot index to combine equipment"""
    slotIndex: Int!

    """Sub-recipe ID of this combination"""
    subRecipeId: Int

    """Use hammer point to combine equipment?"""
    useHammerPoint: Boolean
  ): ByteString!

  """Query to craft/enhance items/foods"""
  craftQuery: CraftQuery!
  createAvatar(
    """ear index of avatar."""
    ear: Int = 0

    """hair index of avatar."""
    hair: Int = 0

    """index of avatar in `AgentState.avatarAddresses`.(0~2)"""
    index: Int!

    """lens index of avatar."""
    lens: Int = 0

    """name of avatar.(2~20 characters)"""
    name: String!

    """tail index of avatar."""
    tail: Int = 0
  ): ByteString!
  createPledge(agentAddresses: [Address!]!, mead: Int = 4, patronAddress: Address!): ByteString!
  dailyReward(
    """Avatar address to get daily reward"""
    avatarAddress: Address!
  ): ByteString!
  deliverToOthersGarages(
    """Array of currency ticket and quantity to deliver."""
    fungibleAssetValues: [SimplifyFungibleAssetValueInput!]

    """Array of Fungible ID and count to deliver."""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Memo"""
    memo: String

    """Recipient agent address"""
    recipientAgentAddr: Address!
  ): ByteString!
  endPledge(agentAddress: Address!): ByteString!
  grinding(
    """Address of avatar."""
    avatarAddress: Address!

    """Flag to Charge Action Point."""
    chargeAp: Boolean

    """List of equipment ItemId."""
    equipmentIds: [Guid]!
  ): ByteString
  hackAndSlash(
    """Avatar address."""
    avatarAddress: Address!

    """List of consumable id for use."""
    consumableIds: [Guid]

    """List of costume id for equip."""
    costumeIds: [Guid]

    """List of equipment id for equip."""
    equipmentIds: [Guid]

    """List of rune slot info for equip."""
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    """Buff ID for this stage"""
    stageBuffId: Int

    """Stage ID."""
    stageId: Int!

    """World ID containing the stage ID."""
    worldId: Int!
  ): ByteString!
  hackAndSlashSweep(
    """Action point usage to sweep"""
    actionPoint: Int!

    """AP stone usage to sweep"""
    apStoneCount: Int

    """Avatar address."""
    avatarAddress: Address!

    """List of costume id for equip."""
    costumeIds: [Guid]

    """List of equipment id for equip."""
    equipmentIds: [Guid]

    """List of rune slot info for equip."""
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    """Stage ID."""
    stageId: Int!

    """World ID containing the stage ID."""
    worldId: Int!
  ): ByteString!
  issueToken(
    """Avatar address"""
    avatarAddress: Address!

    """List of FungibleAssetValues for wrapping token"""
    fungibleAssetValues: [FungibleAssetValueInputType!]!

    """List of pair of item id, count for wrapping token"""
    items: [IssueTokenItemsInputType!]!
  ): ByteString!
  itemEnhancement(
    """Avatar address to enhance item"""
    avatarAddress: Address!

    """Target item ID to enhance"""
    itemId: Guid!

    """Material IDs to enhance"""
    materialIds: [Guid!]!

    """Slot index to enhance item"""
    slotIndex: Int!
  ): ByteString!
  loadIntoMyGarages(
    """Array of balance address and currency ticker and quantity."""
    fungibleAssetValues: [BalanceInput!]

    """Array of fungible ID and count"""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Inventory Address"""
    inventoryAddr: Address

    """Memo"""
    memo: String
  ): ByteString!
  migrateMonsterCollection(
    """The avatar address to receive monster collection rewards."""
    avatarAddress: Address
  ): ByteString!
  patchTableSheet(
    """table data."""
    tableCsv: String!

    """name of table sheet."""
    tableName: String!
  ): ByteString!
  prepareRewardAssets(
    """list of FungibleAssetValue for charge reward."""
    assets: [FungibleAssetValueInputType!]!

    """address of reward pool for charge reward."""
    rewardPoolAddress: Address!
  ): ByteString!
  raid(
    """address of avatar state."""
    avatarAddress: Address!

    """list of costume id."""
    costumeIds: [Guid] = []

    """list of equipment id."""
    equipmentIds: [Guid] = []

    """list of food id."""
    foodIds: [Guid] = []

    """refill ticket by NCG."""
    payNcg: Boolean = false

    """list of rune slot"""
    runeSlotInfos: [RuneSlotInfoInputType!] = []
  ): ByteString!
  rapidCombination(
    """Avatar address to execute rapid combination"""
    avatarAddress: Address!

    """Slot index list to execute rapid"""
    slotIndexList: [Int!]!
  ): ByteString!
  requestPledge(agentAddress: Address!, mead: Int = 4): ByteString!
  retrieveAvatarAssets(
    """Avatar address to retrieve assets"""
    avatarAddress: Address!
  ): ByteString!
  runeEnhancement(
    """The avatar address to enhance rune."""
    avatarAddress: Address!

    """Rune ID to enhance."""
    runeId: Int!

    """The try count to enhance rune"""
    tryCount: Int
  ): ByteString!
  runeSummon(
    """Avatar address to get summoned items"""
    avatarAddress: Address!

    """Summon group id"""
    groupId: Int!

    """Count to summon. Must between 1 and 10."""
    summonCount: Int!
  ): ByteString!
  stake(
    """An amount to stake."""
    amount: BigInt
  ): ByteString
  transferAsset(
    """A string value to be transferred."""
    amount: String!

    """A enum value of currency to be transferred."""
    currency: CurrencyEnum

    """A 80-max length string to note."""
    memo: String

    """A currency to be transferred."""
    rawCurrency: CurrencyInput

    """Address of recipient."""
    recipient: Address!

    """Address of sender."""
    sender: Address!
  ): ByteString
  transferAssets(
    """A 80-max length string to note."""
    memo: String

    """List of tuples that recipients' address and asset amount to be sent"""
    recipients: [RecipientsInputType!]!

    """Address of sender."""
    sender: Address!
  ): ByteString!
  unloadFromMyGarages(
    """Array of balance address and currency ticker and quantity to send."""
    fungibleAssetValues: [BalanceInput!]

    """Array of fungible ID and count to send."""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Memo"""
    memo: String

    """Recipient avatar address"""
    recipientAvatarAddr: Address!
  ): ByteString!
  unlockEquipmentRecipe(
    """Address of avatar."""
    avatarAddress: Address!

    """List of EquipmentRecipeSheet row ids to unlock."""
    recipeIds: [Int]!
  ): ByteString
  unlockWorld(
    """Address of avatar."""
    avatarAddress: Address!

    """List of WorldUnlockSheet row world_id_to_unlock."""
    worldIds: [Int]!
  ): ByteString
}

type ActionTxQuery {
  approvePledge(patronAddress: Address!): ByteString!
  auraSummon(
    """Avatar address to get summoned items"""
    avatarAddress: Address!

    """Summon group id"""
    groupId: Int!

    """Count to summon. Must between 1 and 10."""
    summonCount: Int!
  ): ByteString!
  claimItems(
    """List of pair of avatar address, List<FAV> to claim."""
    claimData: [ClaimDataInputType!]!

    """Memo to attach to this action."""
    memo: String
  ): ByteString!
  claimRaidReward(
    """address of avatar state to receive reward."""
    avatarAddress: Address!
  ): ByteString!
  claimStakeReward(
    """The avatar address to receive staking rewards."""
    avatarAddress: Address
  ): ByteString
  claimWorldBossKillReward(
    """address of avatar state to receive reward."""
    avatarAddress: Address!
  ): ByteString!
  combinationConsumable(
    """Avatar address to combine consumable"""
    avatarAddress: Address!

    """Recipe ID to combine consumable"""
    recipeId: Int!

    """Slot index to combine"""
    slotIndex: Int!
  ): ByteString!
  combinationEquipment(
    """Avatar address to combine equipment"""
    avatarAddress: Address!

    """Pay crystal co combine equipment?"""
    payByCrystal: Boolean

    """Combination recipe ID"""
    recipeId: Int!

    """Slot index to combine equipment"""
    slotIndex: Int!

    """Sub-recipe ID of this combination"""
    subRecipeId: Int

    """Use hammer point to combine equipment?"""
    useHammerPoint: Boolean
  ): ByteString!

  """Query to craft/enhance items/foods"""
  craftQuery: CraftQuery!
  createAvatar(
    """ear index of avatar."""
    ear: Int = 0

    """hair index of avatar."""
    hair: Int = 0

    """index of avatar in `AgentState.avatarAddresses`.(0~2)"""
    index: Int!

    """lens index of avatar."""
    lens: Int = 0

    """name of avatar.(2~20 characters)"""
    name: String!

    """tail index of avatar."""
    tail: Int = 0
  ): ByteString!
  createPledge(agentAddresses: [Address!]!, mead: Int = 4, patronAddress: Address!): ByteString!
  dailyReward(
    """Avatar address to get daily reward"""
    avatarAddress: Address!
  ): ByteString!
  deliverToOthersGarages(
    """Array of currency ticket and quantity to deliver."""
    fungibleAssetValues: [SimplifyFungibleAssetValueInput!]

    """Array of Fungible ID and count to deliver."""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Memo"""
    memo: String

    """Recipient agent address"""
    recipientAgentAddr: Address!
  ): ByteString!
  endPledge(agentAddress: Address!): ByteString!
  grinding(
    """Address of avatar."""
    avatarAddress: Address!

    """Flag to Charge Action Point."""
    chargeAp: Boolean

    """List of equipment ItemId."""
    equipmentIds: [Guid]!
  ): ByteString
  hackAndSlash(
    """Avatar address."""
    avatarAddress: Address!

    """List of consumable id for use."""
    consumableIds: [Guid]

    """List of costume id for equip."""
    costumeIds: [Guid]

    """List of equipment id for equip."""
    equipmentIds: [Guid]

    """List of rune slot info for equip."""
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    """Buff ID for this stage"""
    stageBuffId: Int

    """Stage ID."""
    stageId: Int!

    """World ID containing the stage ID."""
    worldId: Int!
  ): ByteString!
  hackAndSlashSweep(
    """Action point usage to sweep"""
    actionPoint: Int!

    """AP stone usage to sweep"""
    apStoneCount: Int

    """Avatar address."""
    avatarAddress: Address!

    """List of costume id for equip."""
    costumeIds: [Guid]

    """List of equipment id for equip."""
    equipmentIds: [Guid]

    """List of rune slot info for equip."""
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    """Stage ID."""
    stageId: Int!

    """World ID containing the stage ID."""
    worldId: Int!
  ): ByteString!
  issueToken(
    """Avatar address"""
    avatarAddress: Address!

    """List of FungibleAssetValues for wrapping token"""
    fungibleAssetValues: [FungibleAssetValueInputType!]!

    """List of pair of item id, count for wrapping token"""
    items: [IssueTokenItemsInputType!]!
  ): ByteString!
  itemEnhancement(
    """Avatar address to enhance item"""
    avatarAddress: Address!

    """Target item ID to enhance"""
    itemId: Guid!

    """Material IDs to enhance"""
    materialIds: [Guid!]!

    """Slot index to enhance item"""
    slotIndex: Int!
  ): ByteString!
  loadIntoMyGarages(
    """Array of balance address and currency ticker and quantity."""
    fungibleAssetValues: [BalanceInput!]

    """Array of fungible ID and count"""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Inventory Address"""
    inventoryAddr: Address

    """Memo"""
    memo: String
  ): ByteString!
  migrateMonsterCollection(
    """The avatar address to receive monster collection rewards."""
    avatarAddress: Address
  ): ByteString!
  patchTableSheet(
    """table data."""
    tableCsv: String!

    """name of table sheet."""
    tableName: String!
  ): ByteString!
  prepareRewardAssets(
    """list of FungibleAssetValue for charge reward."""
    assets: [FungibleAssetValueInputType!]!

    """address of reward pool for charge reward."""
    rewardPoolAddress: Address!
  ): ByteString!
  raid(
    """address of avatar state."""
    avatarAddress: Address!

    """list of costume id."""
    costumeIds: [Guid] = []

    """list of equipment id."""
    equipmentIds: [Guid] = []

    """list of food id."""
    foodIds: [Guid] = []

    """refill ticket by NCG."""
    payNcg: Boolean = false

    """list of rune slot"""
    runeSlotInfos: [RuneSlotInfoInputType!] = []
  ): ByteString!
  rapidCombination(
    """Avatar address to execute rapid combination"""
    avatarAddress: Address!

    """Slot index list to execute rapid"""
    slotIndexList: [Int!]!
  ): ByteString!
  requestPledge(agentAddress: Address!, mead: Int = 4): ByteString!
  retrieveAvatarAssets(
    """Avatar address to retrieve assets"""
    avatarAddress: Address!
  ): ByteString!
  runeEnhancement(
    """The avatar address to enhance rune."""
    avatarAddress: Address!

    """Rune ID to enhance."""
    runeId: Int!

    """The try count to enhance rune"""
    tryCount: Int
  ): ByteString!
  runeSummon(
    """Avatar address to get summoned items"""
    avatarAddress: Address!

    """Summon group id"""
    groupId: Int!

    """Count to summon. Must between 1 and 10."""
    summonCount: Int!
  ): ByteString!
  stake(
    """An amount to stake."""
    amount: BigInt
  ): ByteString
  transferAsset(
    """A string value to be transferred."""
    amount: String!

    """A enum value of currency to be transferred."""
    currency: CurrencyEnum

    """A 80-max length string to note."""
    memo: String

    """A currency to be transferred."""
    rawCurrency: CurrencyInput

    """Address of recipient."""
    recipient: Address!

    """Address of sender."""
    sender: Address!
  ): ByteString
  transferAssets(
    """A 80-max length string to note."""
    memo: String

    """List of tuples that recipients' address and asset amount to be sent"""
    recipients: [RecipientsInputType!]!

    """Address of sender."""
    sender: Address!
  ): ByteString!
  unloadFromMyGarages(
    """Array of balance address and currency ticker and quantity to send."""
    fungibleAssetValues: [BalanceInput!]

    """Array of fungible ID and count to send."""
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    """Memo"""
    memo: String

    """Recipient avatar address"""
    recipientAvatarAddr: Address!
  ): ByteString!
  unlockEquipmentRecipe(
    """Address of avatar."""
    avatarAddress: Address!

    """List of EquipmentRecipeSheet row ids to unlock."""
    recipeIds: [Int]!
  ): ByteString
  unlockWorld(
    """Address of avatar."""
    avatarAddress: Address!

    """List of WorldUnlockSheet row world_id_to_unlock."""
    worldIds: [Int]!
  ): ByteString
}

type ActivationStatusQuery {
  addressActivated(address: Address!): Boolean! @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
}

scalar Address

type AddressQuery {
  """currency minters address."""
  currencyMintersAddress(
    """
    A currency type. see also: https://github.com/planetarium/NineChronicles.Headless/blob/main/NineChronicles.Headless/GraphTypes/CurrencyEnumType.cs
    """
    currency: CurrencyEnum!
  ): [Address!]

  """pledge information address."""
  pledgeAddress(
    """address of agent state."""
    agentAddress: Address!
  ): Address!

  """user information address by world boss season."""
  raiderAddress(
    """address of avatar state."""
    avatarAddress: Address!

    """world boss season id."""
    raidId: Int!
  ): Address!

  """raider list address by world boss season."""
  raiderListAddress(
    """world boss season id."""
    raidId: Int!
  ): Address!

  """boss information address by world boss season."""
  worldBossAddress(
    """world boss season id."""
    raidId: Int!
  ): Address!

  """user boss kill reward record address by world boss season."""
  worldBossKillRewardRecordAddress(
    """address of avatar state."""
    avatarAddress: Address!

    """world boss season id."""
    raidId: Int!
  ): Address!
}

type AgentStateType {
  """Address of agent."""
  address: Address!

  """List of avatar."""
  avatarStates: [AvatarStateType!]

  """Current CRYSTAL."""
  crystal: String!

  """Current NCG."""
  gold: String!
  hasTradedItem: Boolean!

  """Current monster collection level."""
  monsterCollectionLevel: Long!

  """Monster collection round of agent."""
  monsterCollectionRound: Long!

  """mead pledge information."""
  pledge: MeadPledgeType!
}

type AppProtocolVersionType {
  extra: ByteString
  signature: ByteString!
  signer: Address!
  version: Int!
}

type ArenaInfoType {
  active: Boolean!
  agentAddress: Address!
  arenaRecord: ArenaRecordType!
  avatarAddress: Address!
  avatarName: String!
  dailyChallengeCount: Int!
  score: Int!
}

type ArenaInformationType {
  address: Address!
  avatarAddress: Address!
  lose: Int!
  purchasedTicketCount: Int!
  score: Int!
  ticket: Int!
  ticketResetCount: Int!
  win: Int!
}

type ArenaParticipantType {
  """Address of avatar."""
  avatarAddr: Address!

  """Cp of avatar."""
  cp: Int!

  """Level of avatar."""
  level: Int!

  """Score for defeat."""
  loseScore: Int!

  """Name of avatar."""
  nameWithHash: String!

  """Portrait icon id."""
  portraitId: Int!

  """Arena rank of avatar."""
  rank: Int!

  """Arena score of avatar."""
  score: Int!

  """Score for victory."""
  winScore: Int!
}

type ArenaRecordType {
  draw: Int
  lose: Int
  win: Int
}

type AvatarStateType {
  """Current ActionPoint."""
  actionPoint: Int!

  """Address of avatar."""
  address: Address!

  """Address of agent."""
  agentAddress: Address!

  """Block index at the latest executed action."""
  blockIndex: Int!

  """Character ID from CharacterSheet."""
  characterId: Int!

  """Combination slots."""
  combinationSlots: [CombinationSlotStateType!]!

  """Block index at the DailyReward execution."""
  dailyRewardReceivedIndex: Long!

  """Index of ear color."""
  ear: Int!

  """List of quest event ID."""
  eventMap: CollectionMapType!

  """Avatar total EXP."""
  exp: Int!

  """Index of hair color."""
  hair: Int!

  """The index of this avatar state among its agent's avatar addresses."""
  index: Int!

  """Avatar inventory."""
  inventory: InventoryType!

  """Avatar inventory address."""
  inventoryAddress: Address!

  """List of acquired item ID."""
  itemMap: CollectionMapType!

  """Index of eye color."""
  lens: Int!

  """Avatar Level."""
  level: Int!

  """List of mail."""
  mailBox: MailBoxType!

  """List of defeated monster ID."""
  monsterMap: CollectionMapType!

  """Avatar name."""
  name: String!

  """List of quest."""
  questList: QuestListType!

  """Rune list of avatar"""
  runes: [RuneStateType!]!

  """List of cleared stage ID."""
  stageMap: CollectionMapType!

  """Index of tail color."""
  tail: Int!

  """Block index at the latest executed action."""
  updatedAt: Long!

  """World & Stage information."""
  worldInformation: WorldInformationType!
}

input BalanceInput {
  """Balance Address."""
  balanceAddr: Address

  """Fungible asset value ticker and amount."""
  value: SimplifyFungibleAssetValueInput
}

scalar BencodexValue

scalar BigInt

type Block {
  """The mining difficulty that the block's nonce has to satisfy."""
  difficulty: Long! @deprecated(reason: "Block does not have Difficulty field in PBFT.")

  """Evidence belonging to the block."""
  evidence: [Evidence!]!

  """A block's hash."""
  hash: ID!

  """The height of the block."""
  index: Long!

  """The LastCommit of the block."""
  lastCommit: BlockCommit

  """The address of the miner."""
  miner: Address!

  """The proof-of-work nonce which satisfies the required difficulty."""
  nonce: ByteString! @deprecated(reason: "Block does not have Nonce field in PBFT.")

  """The hash of PreEvaluationBlock."""
  preEvaluationHash: ByteString!

  """
  The previous block.  If it's a genesis block (i.e., its index is 0) this must be null.
  """
  previousBlock: Block

  """The protocol version number of the block."""
  protocolVersion: Int!

  """The public key of the Miner."""
  publicKey: PublicKey

  """
  The digital signature of the whole block content (except for hash, which is derived from the signature and other contents)
  """
  signature: ByteString

  """
  The hash of the resulting states after evaluating transactions and a block action (if exists)
  """
  stateRootHash: ByteString!
  timestamp: DateTimeOffset!

  """
  The total mining difficulty since the genesis including the block's difficulty.
  """
  totalDifficulty: BigInt! @deprecated(reason: "Block does not have TotalDifficulty field in PBFT.")

  """Transactions belonging to the block."""
  transactions: [Transaction!]!
}

type BlockCommit {
  """The hash of the block which contains block commit."""
  blockHash: ID!

  """The height of the block commit."""
  height: Long!

  """The round of the block commit."""
  round: Int!

  """Total votes of the block commit."""
  votes: [Vote!]!
}

scalar BlockHash

type BlockHeader {
  hash: String!
  id: ID!
  index: Int!
  miner: Address
}

type BlockQuery {
  block(hash: ID, index: ID): Block
  blocks(
    """Whether to query blocks in descending order or not."""
    desc: Boolean! = false

    """
    The maximum number of blocks to return.  This limits the offset index range to query, not the result, i.e. excluded blocks due to a block being empty or not matching the miner (if specified in other arguments) are still counted.
    """
    limit: Int

    """The offset of the first queried block."""
    offset: Int! = 0
  ): [Block!]!
}

type BoundPeer {
  """The endpoint of the peer."""
  endPoint: String!

  """The address of the miner."""
  publicIpAddress: String

  """The public key of the peer."""
  publicKey: PublicKey!
}

scalar Byte

scalar ByteString

input ClaimDataInputType {
  avatarAddress: Address!
  fungibleAssetValues: [FungibleAssetValueInputType!]!
}

type ClearedStageType {
  stageId: Int!
  worldId: Int!
}

type CollectionMapType {
  count: Int!
  pairs: [[Int]!]!
}

type CombinationSlotStateType {
  """Address of combination slot."""
  address: Address!

  """Slot Index at the combination slot"""
  index: Int!

  """Is the combination slot unlocked"""
  isUnlocked: Boolean!

  """Pet id used in equipment"""
  petId: Int

  """Block index at the combination started."""
  startBlockIndex: Long!

  """Block index at the combination slot can be usable."""
  unlockBlockIndex: Long!
}

type ConsumableType {
  """Item elemental."""
  elementalType: ElementalType!

  """Grade from ItemSheet."""
  grade: Int!

  """ID from ItemSheet."""
  id: Int!
  itemId: Guid!

  """Item subcategory."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
  mainStat: StatType!
  requiredBlockIndex: Long
}

type CostumeType {
  """Item elemental."""
  elementalType: ElementalType!

  """Status of Avatar equipped."""
  equipped: Boolean!

  """Grade from ItemSheet."""
  grade: Int!

  """ID from ItemSheet."""
  id: Int!

  """Guid of costume."""
  itemId: Guid!

  """Item subcategory."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
  requiredBlockIndex: Long
}

type CraftQuery {
  eventConsumableItemCrafts(
    """Avatar address to craft event item"""
    avatarAddress: Address!

    """Recipe ID of event item to craft"""
    eventConsumableItemRecipeId: Int!

    """The ID of event schedule"""
    eventScheduleId: Int!

    """Target slot index to craft item"""
    slotIndex: Int!
  ): ByteString!
  eventMaterialItemCrafts(
    """Avatar address to craft item"""
    avatarAddress: Address!

    """Recipe ID of event item to craft"""
    eventMaterialItemRecipeId: Int!

    """The ID of event schedule"""
    eventScheduleId: Int!

    """Materials to be used to craft"""
    materialsToUse: [MaterialsToUseInputType!]!
  ): ByteString!
}

type CrystalMonsterCollectionMultiplierRowType {
  level: Int!
  multiplier: Int!
}

type CrystalMonsterCollectionMultiplierSheetType {
  orderedList: [CrystalMonsterCollectionMultiplierRowType!]!
}

type Currency {
  """The number of digits to treat as minor units (i.e., exponents)."""
  decimalPlaces: Byte!

  """The deterministic hash derived from other fields."""
  hash: ByteString!

  """
  The uppermost quantity of currency allowed to exist.  null means unlimited supply.
  """
  maximumSupply: FungibleAssetValue

  """
  The addresses who can mint this currency.  If this is null anyone can mint the currency.  On the other hand, unlike null, an empty set means no one can mint the currency.
  """
  minters: [Address!]

  """The ticker symbol, e.g., USD."""
  ticker: String!

  """Whether the total supply of this currency is trackable."""
  totalSupplyTrackable: Boolean!
}

"""The currency type."""
enum CurrencyEnum {
  CRYSTAL
  GARAGE
  MEAD
  NCG
  RUNESTONE_FREYA_BLESSING
  RUNESTONE_FREYA_LIBERATION
  RUNESTONE_ODIN_WEAKNESS
  RUNESTONE_ODIN_WISDOM
  RUNE_ADVENTURER
  RUNE_GOLDENLEAF
}

input CurrencyInput {
  """The number of digits to treat as minor units (i.e., exponents)."""
  decimalPlaces: Byte!
  maximumSupplyMajorUnit: BigInt
  maximumSupplyMinorUnit: BigInt

  """
  The addresses who can mint this currency.  If this is null anyone can mint the currency.  On the other hand, unlike null, an empty set means no one can mint the currency.
  """
  minters: [Address!]

  """The ticker symbol, e.g., USD."""
  ticker: String!

  """Whether the total supply of this currency is trackable."""
  totalSupplyTrackable: Boolean
}

type CurrencyType {
  decimalPlaces: Byte!
  minters: [Address]
  ticker: String!
}

"""
The `DateTimeOffset` scalar type represents a date, time and offset from UTC. `DateTimeOffset` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
"""
scalar DateTimeOffset

scalar Decimal

type DecimalStatType {
  additionalValue: Decimal!
  baseValue: Decimal!
  statType: StatType!
  totalValue: Decimal!
}

union Diff = RootStateDiff | StateDiff

type DifferentAppProtocolVersionEncounterType {
  localVersion: AppProtocolVersionType!
  peer: String!
  peerVersion: AppProtocolVersionType!
}

enum ElementalType {
  FIRE
  LAND
  NORMAL
  WATER
  WIND
}

type EquipmentType {
  buffSkills: [SkillType]

  """Item elemental."""
  elementalType: ElementalType!
  equipped: Boolean!
  exp: Int!

  """Grade from ItemSheet."""
  grade: Int!

  """ID from ItemSheet."""
  id: Int!
  itemId: Guid!

  """Item subcategory."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
  level: Int!
  requiredBlockIndex: Long
  setId: Int!
  skills: [SkillType]
  stat: DecimalStatType!
  statsMap: StatsMapType!
}

type Evidence {
  """Indicates the block height that infraction has been occurred."""
  height: Long!

  """A unique identifier derived from this Evidence content"""
  id: ID!

  """Indicates the address of the target that caused the infraction."""
  targetAddress: Address!

  """Indicates the timestamp the infraction occurred."""
  timestamp: DateTimeOffset!

  """Evidence type."""
  type: String!
}

scalar EvidenceId

"""Retrieve evidence information."""
type EvidenceQuery {
  committedEvidence(blockHash: BlockHash, desc: Boolean = false, limit: Int = 100, offset: Int = 0): [Evidence!]!
  evidence(id: EvidenceId): Evidence
  pendingEvidence(desc: Boolean = false, limit: Int = 100, offset: Int = 0): [Evidence!]!
}

type ExplorerQuery {
  blockQuery: BlockQuery
  evidenceQuery: EvidenceQuery
  helperQuery: HelperQuery
  nodeState: NodeState!
  rawStateQuery: RawStateQuery
  stateQuery: LibplanetStateQuery
  transactionQuery: TransactionQuery
}

"""Holds a fungible asset value which holds its currency together."""
type FungibleAssetValue {
  """The currency of the fungible asset."""
  currency: Currency!
  majorUnit: BigInt!
  minorUnit: BigInt!

  """The value quantity without its currency in string, e.g., "123.45"."""
  quantity: String!

  """
  Gets a number that indicates the sign (-1: negative, 1: positive, or 0: zero) of the value.
  """
  sign: Int!

  """The value quantity with its currency in string, e.g., "123.45 ABC"."""
  string: String!
}

input FungibleAssetValueInputType {
  decimalPlaces: Byte!
  minters: [Address!]
  quantity: BigInt!
  ticker: String!
}

type FungibleAssetValueType {
  currency: String!
  quantity: String!
}

type FungibleAssetValueWithCurrencyType {
  currency: CurrencyType!
  quantity(minerUnit: Boolean = false): String!
}

input FungibleIdAndCountInput {
  """Count"""
  count: Int!

  """Fungible ID"""
  fungibleId: String!
}

type FungibleItemGarageWithAddressType {
  addr: Address
  count: Int
  fungibleItemId: String
  item: FungibleItemType
}

type FungibleItemType {
  fungibleItemId: String!

  """Item sub category."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
}

type GaragesType {
  agentAddr: Address
  fungibleItemGarages: [FungibleItemGarageWithAddressType]
  garageBalances: [FungibleAssetValue]
  garageBalancesAddr: Address
}

scalar Guid

scalar HashDigestSHA1

scalar HashDigestSHA256

scalar HashDigest_SHA256

"""A number of queries for convenience."""
type HelperQuery {
  """Decodes hex encoded bencodex value"""
  bencodexValue(
    """The byte array in hex representation to decode."""
    hex: String!
  ): IValue!

  """Converts currency info to currency hash."""
  currencyHash(
    """The currency to convert."""
    currency: CurrencyInput!
  ): HashDigestSHA1!

  """Converts string to key hex representation"""
  keyHex(
    """The string value to convert to key hex."""
    value: String!
  ): KeyBytes!
}

type IValue {
  """A base64 representation of the bencodex value encoded to byte array."""
  base64: String!

  """
  A hexadecimal representation of the bencodex value encoded as byte array.
  """
  hex: String!

  """A human readable representation of the bencodex value."""
  inspection: String!

  """A JSON representation of the bencodex value"""
  json: String!
}

type InventoryItemType {
  """A count of item"""
  count: Int!
  fungibleItemId: String

  """An Id of item"""
  id: Int!

  """An ItemType of item"""
  itemType: ItemType!
  lockId: Guid
  locked: Boolean!
  tradableId: Guid
}

type InventoryType {
  """List of Consumables."""
  consumables: [ConsumableType!]!

  """List of Costumes."""
  costumes: [CostumeType!]!

  """List of Equipments."""
  equipments(
    """filter equipped inventory item"""
    equipped: Boolean

    """
    Ids for fetching only equipment where id (number) is in the given argument.
    """
    ids: [Int!]

    """
    ItemIds for fetching only equipment where itemId (Guid) is in the given argument.
    """
    itemIds: [Guid!]

    """
    An item subtype for fetching only equipment where its subtype is the same. If it wasn't given, you'll get all equipment without relationship to the subtype.
    """
    itemSubType: ItemSubType
  ): [EquipmentType!]!

  """List of Inventory Item."""
  items(
    """An Id to find Inventory Item"""
    inventoryItemId: Int

    """filter locked Inventory Item"""
    locked: Boolean
  ): [InventoryItemType!]!

  """List of Materials."""
  materials: [MaterialType!]!
}

input IssueTokenItemsInputType {
  """Count"""
  count: Int!

  """item ID"""
  itemId: Int!

  """item can be tradable"""
  tradable: Boolean!
}

enum ItemSubType {
  AP_STONE
  ARMOR
  AURA
  BELT
  CHEST @deprecated(reason: "ItemSubType.Chest has never been used outside the MaterialItemSheet. And we won't use it in the future until we have a specific reason.")
  CIRCLE
  EAR_COSTUME
  EQUIPMENT_MATERIAL
  EYE_COSTUME
  FOOD
  FOOD_MATERIAL
  FULL_COSTUME
  GRIMOIRE
  HAIR_COSTUME
  HOURGLASS
  MONSTER_PART
  NECKLACE
  NORMAL_MATERIAL
  RING
  SCROLL
  TAIL_COSTUME
  TITLE
  WEAPON
}

enum ItemType {
  CONSUMABLE
  COSTUME
  EQUIPMENT
  MATERIAL
}

type ItemUsableType {
  """Item elemental."""
  elementalType: ElementalType!

  """Grade from ItemSheet."""
  grade: Int!

  """ID from ItemSheet."""
  id: Int!

  """Guid of item."""
  itemId: Guid!

  """Item subcategory."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
  requiredBlockIndex: Long
}

scalar KeyBytes

type KeyStoreMutation {
  createPrivateKey(passphrase: String!, privateKey: ByteString): PrivateKeyType!
  revokePrivateKey(address: Address!): ProtectedPrivateKeyType!
}

type KeyStoreType {
  decryptedPrivateKey(address: Address!, passphrase: String!): ByteString!

  """An API to provide conversion to public-key, address."""
  privateKey(
    """A representation of public-key with hexadecimal format."""
    hex: ByteString!
  ): PrivateKeyType!
  protectedPrivateKeys: [ProtectedPrivateKeyType!]!
}

type LibplanetStateQuery {
  """Retrieves balance from the legacy account."""
  balance(currency: CurrencyInput!, offsetBlockHash: ID, offsetStateRootHash: HashDigest_SHA256, owner: Address!): FungibleAssetValue!

  """Retrieves states from the legacy account."""
  states(addresses: [Address!]!, offsetBlockHash: ID, offsetStateRootHash: HashDigest_SHA256): [BencodexValue]!

  """Retrieves total supply from the legacy account."""
  totalSupply(currency: CurrencyInput!, offsetBlockHash: ID, offsetStateRootHash: HashDigest_SHA256): FungibleAssetValue

  """Retrieves validator set from the legacy account."""
  validators(offsetBlockHash: ID, offsetStateRootHash: HashDigest_SHA256): [Validator!]
  world(blockHash: BlockHash, stateRootHash: HashDigestSHA256): WorldState!
}

scalar Long

type MailBoxType {
  count: Int!
  mails: [MailType!]!
}

type MailType {
  blockIndex: Long!
  id: Guid!
  requiredBlockIndex: Long!
}

type MaterialType {
  """Item elemental."""
  elementalType: ElementalType!

  """Grade from ItemSheet."""
  grade: Int!

  """ID from ItemSheet."""
  id: Int!
  itemId: ByteString!

  """Item subcategory."""
  itemSubType: ItemSubType!

  """Item category."""
  itemType: ItemType!
  requiredBlockIndex: Long
}

input MaterialsToUseInputType {
  """Material ID to be used."""
  materialId: Int!

  """Item quantity to be used."""
  quantity: Int!
}

type MeadPledgeType {
  approved: Boolean!
  mead: Int!
  patronAddress: Address
}

type MonsterCollectionRewardInfoType {
  itemId: Int!
  quantity: Int!
}

type MonsterCollectionRowType {
  level: Int!
  requiredGold: Int!
  rewards: [MonsterCollectionRewardInfoType]!
}

type MonsterCollectionSheetType {
  orderedList: [MonsterCollectionRowType]
}

type MonsterCollectionStateType {
  address: Address!
  claimableBlockIndex: Long!
  expiredBlockIndex: Long!
  level: Long!
  receivedBlockIndex: Long!
  rewardLevel: Long!
  startedBlockIndex: Long!
}

type MonsterCollectionStatusType {
  fungibleAssetValue: FungibleAssetValueType!
  lockup: Boolean!
  rewardInfos: [MonsterCollectionRewardInfoType]
  tipIndex: Long!
}

type MultiAccountInfo {
  agents: [String]
  agentsCount: Int
  ips: [String]
  ipsCount: Int
  key: String!
}

type NodeExceptionType {
  """The code of NodeException."""
  code: Int!

  """The message of NodeException."""
  message: String!
}

type NodeState {
  peers: [BoundPeer!]!
  preloaded: Boolean!
  validators: [BoundPeer!]!
}

type NodeStatusType {
  appProtocolVersion: AppProtocolVersionType

  """Whether the current libplanet node has ended bootstrapping."""
  bootstrapEnded: Boolean!

  """Block header of the genesis block from the current chain."""
  genesis: BlockHeader!

  """
  A informational version (a.k.a. version suffix) of NineChronicles.Headless
  """
  informationalVersion: String

  """Whether the current node is mining."""
  isMining: Boolean!

  """Whether the current libplanet node has ended preloading."""
  preloadEnded: Boolean!

  """A version of NineChronicles.Headless"""
  productVersion: String

  """Ids of staged transactions from the current node."""
  stagedTxIds(
    """Target address to query"""
    address: Address
  ): [TxId]

  """The number of ids of staged transactions from the current node."""
  stagedTxIdsCount: Int

  """A list of subscribers' address"""
  subscriberAddresses: [Address]

  """The number of a list of subscribers' address"""
  subscriberAddressesCount: Int

  """Block header of the tip block from the current canonical chain."""
  tip: BlockHeader!

  """The topmost blocks from the current node."""
  topmostBlocks(
    """The number of blocks to get."""
    limit: Int!

    """
    List only blocks mined by the given address.  (List everything if omitted.)
    """
    miner: Address

    """The number of blocks to skip from tip."""
    offset: Int = 0
  ): [BlockHeader]!
}

enum NotificationEnum {
  BUYER
  COMBINATION_CONSUMABLE
  COMBINATION_EQUIPMENT
  HAS
  REFILL
  SELLER
}

type NotificationType {
  """The message of Notification."""
  message: String

  """The type of Notification."""
  type: NotificationEnum!
}

type OrderDigestListStateType {
  address: Address
  orderDigestList: [OrderDigestType]!
}

type OrderDigestType {
  combatPoint: Int!

  """Block index order expired."""
  expiredBlockIndex: Int!

  """Count of item."""
  itemCount: Int!

  """Id of item."""
  itemId: Int!
  level: Int!

  """Guid of order."""
  orderId: Guid!

  """Order price."""
  price: String!

  """Address of seller agent."""
  sellerAgentAddress: Address!

  """Block index order started."""
  startedBlockIndex: Int!

  """Tradable guid of order."""
  tradableId: Guid!
}

type PeerChainStateQuery {
  """
  Summary of other peers connected to this node. It consists of address, chain height, and total difficulty.
  """
  state: [String]!
}

type PreloadStateExtraType {
  currentCount: Long!
  totalCount: Long!
  type: String!
}

type PreloadStateType {
  currentPhase: Long!
  extra: PreloadStateExtraType!
  totalPhase: Long!
}

type PrivateKeyType {
  """A representation of private-key with hexadecimal format."""
  hex: ByteString!

  """A public-key derived from the private-key."""
  publicKey: PublicKeyType!
}

type ProtectedPrivateKeyType {
  address: Address!
}

scalar PublicKey

type PublicKeyType {
  """An address derived from the public-key."""
  address: Address!

  """A representation of public-key with hexadecimal format."""
  hex(
    """A flag to determine whether to compress public-key."""
    compress: Boolean
  ): ByteString!
}

type QuestListType {
  completedQuestIds: [Int!]!
}

type RaiderStateType {
  """address of avatar state."""
  avatarAddress: Address!

  """name of avatar state."""
  avatarName: String!

  """rank reward claimed block index."""
  claimedBlockIndex: Long!

  """combat point of avatar state."""
  cp: Int!

  """season high score."""
  highScore: Int!

  """icon id for ranking portrait."""
  iconId: Int!

  """latest challenge boss level."""
  latestBossLevel: Int!

  """latest reward claimed season rank."""
  latestRewardRank: Int!

  """level of avatar state."""
  level: Int!

  """challenge ticket purchase count."""
  purchaseCount: Int!

  """ticket refilled block index."""
  refillBlockIndex: Long!

  """remain challenge count before refill."""
  remainChallengeCount: Int!

  """season total challenge count."""
  totalChallengeCount: Int!

  """season total score."""
  totalScore: Int!
}

type RankingInfoType {
  """Address of agent."""
  agentAddress: Address!

  """Equipped Armor ID from EquipmentItemSheet."""
  armorId: Int!

  """Address of avatar."""
  avatarAddress: Address!

  """Avatar name."""
  avatarName: String!

  """Avatar total EXP."""
  exp: Long!

  """Avatar Level."""
  level: Int!

  """Block index at Latest stage cleared."""
  stageClearedBlockIndex: Long!

  """Block index at RankingInfo update."""
  updatedAt: Long!
}

type RankingMapStateType {
  """Address of RankingMapState."""
  address: Address!

  """RankingMapState Capacity."""
  capacity: Int!

  """List of RankingInfo."""
  rankingInfos: [RankingInfoType!]!
}

type RawStateQuery {
  """Retrieves trie from given state root hash."""
  trie(stateRootHash: HashDigest_SHA256): Trie!
}

input RecipientsInputType {
  amount: FungibleAssetValueInputType!
  recipient: Address!
}

type RootStateDiff {
  """List of state differences under this root."""
  diffs: [StateDiff!]!

  """The path to the root state difference."""
  path: String!
}

type RpcInformationQuery {
  """List of address connected to this node."""
  clients: [Address]!

  """clients connected to this node by device."""
  clientsByDevice(device: String!): [Address!]!

  """clients connected to this node grouped by Ip addresses."""
  clientsByIps(minimum: Int!): [MultiAccountInfo]!

  """clients count connected to this node grouped by Ip addresses."""
  clientsCountByIps(minimum: Int!): Int!

  """total count by connected to this node."""
  totalCount: Int!

  """total count by connected to this node."""
  totalCountByDevice(device: String!): Int!
}

input RuneSlotInfoInputType {
  runeId: Int!
  slotIndex: Int!
}

type RuneStateType {
  """Level of this rune."""
  level: Int!

  """ID of rune."""
  runeId: Int!
}

type ShardedShopStateV2Type {
  """Address of sharded shop."""
  address: Address!

  """List of OrderDigest."""
  orderDigestList(
    """Filter for item id."""
    id: Int

    """Filter for item maximum price."""
    maximumPrice: Int
  ): [OrderDigestType]!
}

type ShopItemType {
  """Costume information."""
  costume: CostumeType

  """Equipment / Consumable information."""
  itemUsable: ItemUsableType

  """Item price."""
  price: String!

  """Guid of product registered."""
  productId: Guid!

  """Address of seller agent."""
  sellerAgentAddress: Address!

  """Address of seller avatar."""
  sellerAvatarAddress: Address!
}

type ShopStateType {
  """Address of shop."""
  address: Address!

  """List of ShopItem."""
  products(
    """Filter for item id."""
    id: Int

    """
    Filter for ItemSubType. see from https://github.com/planetarium/lib9c/blob/main/Lib9c/Model/Item/ItemType.cs#L13
    """
    itemSubType: ItemSubType

    """Filter for item maximum price."""
    maximumPrice: Int
  ): [ShopItemType]!
}

"""
A fungible asset value ticker and amount.You can specify either currencyEnum or currencyTicker.
"""
input SimplifyFungibleAssetValueInput {
  """A currency type to be loaded."""
  currencyEnum: CurrencyEnum

  """A currency ticker to be loaded."""
  currencyTicker: String

  """
  A numeric string to parse.  Can consist of digits, plus (+), minus (-), and decimal separator (.). <see cref="FungibleAssetValue.Parse(Currency, string)" />
  """
  value: String!
}

type SkillType {
  chance: Int!
  elementalType: ElementalType!
  id: Int!
  power: Int!
  referencedStatType: StatType!
  statPowerRatio: Int!
}

type StakeAchievementsType {
  """The address of current state."""
  achievementsByLevel(level: Int!): Int!
}

type StakeRegularFixedRewardInfoType {
  count: Int!
  itemId: Int!
}

type StakeRegularRewardInfoType {
  currencyDecimalPlaces: Int
  currencyTicker: String
  decimalRate: Decimal!
  itemId: Int!
  rate: Int!
  type: StakeRewardType!
}

type StakeRegularRewardsType {
  bonusRewards: [StakeRegularFixedRewardInfoType!]!
  level: Int!
  requiredGold: Long!
  rewards: [StakeRegularRewardInfoType!]!
}

enum StakeRewardType {
  CURRENCY
  ITEM
  RUNE
}

type StakeRewardsType {
  orderedList: [StakeRegularRewardsType!]!
}

type StakeStateType {
  """The staking achievements."""
  achievements: StakeAchievementsType @deprecated(reason: "Since StakeStateV2, the achievement became removed.")

  """The address of current state."""
  address: Address!

  """The block index the user can cancel the staking."""
  cancellableBlockIndex: Long!

  """The block index the user can claim rewards."""
  claimableBlockIndex: Long!

  """The staked amount."""
  deposit: String!

  """The block index the user received rewards."""
  receivedBlockIndex: Long!
  stakeRewards: StakeRewardsType!

  """The block index the user started to stake."""
  startedBlockIndex: Long!
}

type StandaloneMutation {
  action: ActionMutation
  keyStore: KeyStoreMutation @deprecated(reason: "Use `planet key` command instead.  https://www.npmjs.com/package/@planetarium/cli")

  """Add a new transaction to staging and return TxId"""
  stageTransaction(
    """The hexadecimal string of the transaction to stage."""
    payload: String!
  ): TxId!

  """Add a new transaction to staging"""
  stageTx(
    """The base64-encoded bytes for new transaction."""
    payload: String!
  ): Boolean!

  """Add a new transaction to staging and return TxId"""
  stageTxV2(
    """The base64-encoded bytes for new transaction."""
    payload: String!
  ): TxId! @deprecated(reason: "API update with action query. use stageTransaction mutation")
  transfer(
    """A string value of the value to be transferred."""
    amount: String!

    """
    A hex-encoded value for address of currency to be transferred. The default is the NCG's address.
    """
    currencyAddress: String! = "000000000000000000000000000000000000000A"

    """A 80-max length string to note."""
    memo: String

    """A hex-encoded value for address of recipient."""
    recipient: Address!

    """A sender's transaction counter. You can get it through nextTxNonce()."""
    txNonce: Long!
  ): TxId
  transferGold(amount: String!, recipient: Address!): TxId @deprecated(reason: "Incorrect remittance may occur when using transferGold() to the same address consecutively. Use transfer() instead.")
}

type StandaloneQuery {
  """
  This field allows you to query the diffs based accountAddress between two blocks. `baseIndex` is the reference block index, and changedIndex is the block index from which to check what changes have occurred relative to `baseIndex`. Both indices must not be higher than the current block on the chain nor lower than the genesis block index (0). The difference between the two blocks must be greater than zero for a valid comparison and less than ten for performance reasons.
  """
  accountDiffs(
    """The target accountAddress."""
    accountAddress: Address!

    """The index of the reference block from which the state is retrieved."""
    baseIndex: Long!

    """The index of the target block for comparison."""
    changedIndex: Long!
  ): [StateDiff!]!

  """Query to create action transaction."""
  actionQuery: ActionQuery!
  actionTxQuery(
    maxGasPrice: FungibleAssetValueInputType = {decimalPlaces: 18, minters: null, quantity: 1000000000000000000, ticker: "Mead"}

    """The nonce for Transaction."""
    nonce: Long

    """The hexadecimal string of public key for Transaction."""
    publicKey: String!

    """The time this transaction is created."""
    timestamp: DateTimeOffset
  ): ActionTxQuery!
  activated(invitationCode: String!): Boolean! @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  activationKeyNonce(invitationCode: String!): String! @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")

  """Check if the provided address is activated."""
  activationStatus: ActivationStatusQuery! @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")

  """Query to get derived address."""
  addressQuery: AddressQuery!
  chainQuery: ExplorerQuery! @deprecated(reason: "Use /graphql/explorer")

  """
  This field allows you to query the diffs between two blocks. `baseIndex` is the reference block index, and changedIndex is the block index from which to check what changes have occurred relative to `baseIndex`. Both indices must not be higher than the current block on the chain nor lower than the genesis block index (0). The difference between the two blocks must be greater than zero for a valid comparison and less than ten for performance reasons.
  """
  diffs(
    """The index of the reference block from which the state is retrieved."""
    baseIndex: Long!

    """The index of the target block for comparison."""
    changedIndex: Long!
  ): [Diff!]!
  getTx(
    """transaction id."""
    txId: TxId!
  ): TransactionType @deprecated(reason: "The root query is not the best place for getTx so it was moved. Use transaction.getTx()")
  goldBalance(
    """Target address to query"""
    address: Address!

    """Offset block hash for query."""
    hash: ByteString
  ): String!
  keyStore: KeyStoreType @deprecated(reason: "Use `planet key` command instead.  https://www.npmjs.com/package/@planetarium/cli")

  """Address of current node."""
  minerAddress: Address

  """Get monster collection status by address."""
  monsterCollectionStatus(
    """agent address."""
    address: Address
  ): MonsterCollectionStatusType
  nextTxNonce(
    """Target address to query"""
    address: Address!
  ): Long! @deprecated(reason: "The root query is not the best place for nextTxNonce so it was moved. Use transaction.nextTxNonce()")
  nodeStatus: NodeStatusType!

  """Get the peer's block chain state"""
  peerChainState: PeerChainStateQuery!

  """Query for rpc mode information."""
  rpcInformation: RpcInformationQuery!
  state(
    """The address of account to fetch from the chain."""
    accountAddress: Address!

    """The address of state to fetch from the account."""
    address: Address!

    """The hash of the block used to fetch state from chain."""
    hash: ByteString

    """The index of the block used to fetch state from chain."""
    index: Long
  ): ByteString
  stateQuery(
    """Offset block hash for query."""
    hash: ByteString

    """Offset block index for query."""
    index: Long
  ): StateQuery!

  """Query for transaction."""
  transaction: TransactionHeadlessQuery!
  transferNCGHistories(blockHash: ByteString!, recipient: Address): [TransferNCGHistoryType!]!

  """The validation method provider for Libplanet types."""
  validation: ValidationQuery!
}

type StandaloneSubscription {
  balanceByAgent(
    """A hex-encoded address of agent."""
    address: Address!
  ): String!
  differentAppProtocolVersionEncounter: DifferentAppProtocolVersionEncounterType!
  nodeException: NodeExceptionType!
  nodeStatus: NodeStatusType
  notification: NotificationType!
  preloadProgress: PreloadStateType @deprecated(reason: "Since Libplanet 5.3.0 preload progress is no longer reported.")
  tipChanged: TipChanged
  tx(
    """A regular expression to filter transactions based on action type."""
    actionType: String!
  ): TxType
}

enum StatType {
  ARMOR_PENETRATION
  ATK
  CDMG
  CRI
  DEF
  DRR
  DRV
  HIT
  HP
  NONE
  SPD
  THORN
}

type StateDiff {
  """The base state before changes."""
  baseState: String!

  """The state after changes."""
  changedState: String

  """The path of the state difference."""
  path: String!
}

type StateQuery {
  """State for agent."""
  agent(
    """Address of agent."""
    address: Address!
  ): AgentStateType

  """List of arena information of requested arena and avatar list"""
  arenaInformation(
    """List of avatar address to get arena information"""
    avatarAddresses: [Address!]!

    """Championship ID to get arena information"""
    championshipId: Int!

    """Round of championship to get arena information"""
    round: Int!
  ): [ArenaInformationType!]!
  arenaParticipants(avatarAddress: Address!, filterBounds: Boolean! = true): [ArenaParticipantType]!

  """State for avatar."""
  avatar(
    """Address of avatar."""
    avatarAddress: Address!
  ): AvatarStateType

  """Avatar states having some order as addresses"""
  avatars(
    """Addresses of avatars to query."""
    addresses: [Address!]!
  ): [AvatarStateType]!

  """asset balance by currency."""
  balance(address: Address!, currency: CurrencyInput!): FungibleAssetValueWithCurrencyType!
  cachedSheet(tableName: String!): String
  crystalMonsterCollectionMultiplierSheet: CrystalMonsterCollectionMultiplierSheetType

  """
  Get balances and fungible items in garages.
  Use either `currencyEnums` or `currencyTickers` to get balances.
  """
  garages(
    """Agent address to get balances and fungible items in garages"""
    agentAddr: Address!

    """List of currency enums to get balances in garages"""
    currencyEnums: [CurrencyEnum!]

    """List of currency tickers to get balances in garages"""
    currencyTickers: [String!]

    """List of fungible item IDs to get fungible item in garages"""
    fungibleItemIds: [String!]
  ): GaragesType

  """The latest stake rewards based on StakePolicySheet."""
  latestStakeRewards: StakeRewardsType
  monsterCollectionSheet: MonsterCollectionSheetType

  """State for monster collection."""
  monsterCollectionState(
    """Address of agent."""
    agentAddress: Address!
  ): MonsterCollectionStateType
  orderDigestList(avatarAddress: Address!): OrderDigestListStateType
  pledge(agentAddress: Address!): MeadPledgeType!

  """world boss season id by block index."""
  raidId(
    blockIndex: Long!

    """find previous raid id."""
    prev: Boolean = false
  ): Int!

  """raider address list by world boss season."""
  raiderList(raiderListAddress: Address!): [Address!]

  """world boss season user information."""
  raiderState(
    """address of world boss season."""
    raiderAddress: Address!
  ): RaiderStateType

  """State for avatar EXP record."""
  rankingMap(
    """RankingMapState index. 0 ~ 99"""
    index: Int!
  ): RankingMapStateType

  """State for sharded shop."""
  shardedShop(
    """
    ItemSubType for shard. see from https://github.com/planetarium/lib9c/blob/main/Lib9c/Model/Item/ItemType.cs#L13
    """
    itemSubType: ItemSubType!

    """
    Nonce for shard. It's not considered if itemSubtype is kind of costume or title. 0 ~ 15
    """
    nonce: Int!
  ): ShardedShopStateV2Type

  """State for shop."""
  shop: ShopStateType @deprecated(reason: "Shop is migrated to ShardedShop and not using now. Use shardedShop() instead.")
  stakeRewards: StakeRewardsType @deprecated(reason: "Since stake3, claim_stake_reward9 actions, each stakers have their own contracts.")

  """State for staking."""
  stakeState(
    """Address of agent who staked."""
    address: Address!
  ): StakeStateType

  """Staking states having same order as addresses"""
  stakeStates(
    """Addresses of agent who staked."""
    addresses: [Address]!
  ): [StakeStateType]!

  """List of unlocked equipment recipe sheet row ids."""
  unlockedRecipeIds(
    """Address of avatar."""
    avatarAddress: Address!
  ): [Int]

  """List of unlocked world sheet row ids."""
  unlockedWorldIds(
    """Address of avatar."""
    avatarAddress: Address!
  ): [Int]

  """State for weekly arena."""
  weeklyArena(
    """WeeklyArenaState index. It increases every 56,000 blocks."""
    index: Int!
  ): WeeklyArenaStateType

  """user boss kill reward record by world boss season."""
  worldBossKillRewardRecord(worldBossKillRewardRecordAddress: Address!): WorldBossKillRewardRecordType

  """world boss season boss information."""
  worldBossState(bossAddress: Address!): WorldBossStateType
}

type StatsMapType {
  aTK: Int!
  cRI: Int!
  dEF: Int!
  hIT: Int!
  hP: Int!
  sPD: Int!
}

type TipChanged {
  hash: ByteString
  index: Long!
}

type Transaction {
  """A list of actions in this transaction."""
  actions: [Action!]!

  """The block including the transaction."""
  blockRef: Block!

  """A unique identifier derived from this transaction content."""
  id: ID!

  """
  The number of previous transactions committed by the signer of this tx.
  """
  nonce: Long!

  """A PublicKey of the account who signed this transaction."""
  publicKey: ByteString!

  """A serialized tx payload in base64 string."""
  serializedPayload: String!

  """A digital signature of the content of this transaction."""
  signature: ByteString!

  """An address of the account who signed this transaction."""
  signer: Address!

  """The time this transaction was created and signed."""
  timestamp: DateTimeOffset!

  """Addresses whose states were affected by Actions."""
  updatedAddresses: [Address!]!
}

type TransactionHeadlessQuery {
  attachSignature(
    """The base64-encoded signature of the given unsigned transaction."""
    signature: String!

    """The base64-encoded unsigned transaction to attach the given signature."""
    unsignedTransaction: String!
  ): String! @deprecated(reason: "Use signTransaction")
  createUnsignedTx(
    """The nonce for Transaction."""
    nonce: Long

    """The base64-encoded plain value of action for Transaction."""
    plainValue: String!

    """The base64-encoded public key for Transaction."""
    publicKey: String!
  ): String! @deprecated(reason: "API update with action query. use unsignedTransaction")
  getTx(
    """transaction id."""
    txId: TxId!
  ): TransactionType
  ncTransactions(
    """filter tx by having actions' type. It is regular expression."""
    actionType: String!

    """number of block to query."""
    limit: Long!

    """start block index for query tx."""
    startingBlockIndex: Long!

    """filter txStatus."""
    txStatusFilter: [TxStatus!]
  ): [TransactionType]
  nextTxNonce(
    """Target address to query"""
    address: Address!
  ): Long!
  signTransaction(
    """The hexadecimal string of signature of the given unsigned transaction."""
    signature: String!

    """
    The hexadecimal string of unsigned transaction to attach the given signature.
    """
    unsignedTransaction: String!
  ): ByteString!
  transactionResult(
    """transaction id."""
    txId: TxId!
  ): TxResultType!
  transactionResults(
    """transaction ids."""
    txIds: [TxId]!
  ): [TxResultType]!
  unsignedTransaction(
    maxGasPrice: FungibleAssetValueInputType = {decimalPlaces: 18, minters: null, quantity: 1000000000000000000, ticker: "Mead"}

    """The nonce for Transaction."""
    nonce: Long

    """The hexadecimal string of plain value for Action."""
    plainValue: String!

    """The hexadecimal string of public key for Transaction."""
    publicKey: String!
  ): ByteString!
}

type TransactionQuery {
  """
  Attach the given signature to the given transaction and return tx as hexadecimal
  """
  bindSignature(
    """The hexadecimal string of the given unsigned transaction."""
    signature: String!

    """
    The hexadecimal string of unsigned transaction to attach the given signature.
    """
    unsignedTransaction: String!
  ): String!
  nextNonce(
    """Address of the account to get the next tx nonce."""
    address: Address!
  ): Long!
  stagedTransactions(desc: Boolean = false, involvedAddress: Address, limit: Int, offset: Int = 0, signer: Address): [Transaction!]!
  transaction(id: ID): Transaction
  transactionResult(
    """transaction id."""
    txId: ID!
  ): TxResultType!
  transactions(desc: Boolean = false, involvedAddress: Address, limit: Int, offset: Int = 0, signer: Address): [Transaction!]!
  unsignedTransaction(
    """The nonce for Transaction."""
    nonce: Long

    """The hexadecimal string of plain value for Action."""
    plainValue: String!

    """The hexadecimal string of public key for Transaction."""
    publicKey: String!
  ): ByteString!
}

type TransactionType {
  """A list of actions in this transaction."""
  actions: [Action]!

  """A unique identifier derived from this transaction content."""
  id: TxId!

  """
  The number of previous transactions committed by the signer of this transaction.
  """
  nonce: Long!

  """A PublicKey of the account who signed this transaction."""
  publicKey: PublicKeyType!

  """A serialized tx payload in base64 string."""
  serializedPayload: String!

  """A digital signature of the content of this transaction."""
  signature: ByteString!

  """An address of the account who signed this transaction."""
  signer: Address!

  """The time this transaction was created and signed."""
  timestamp: String!

  """Addresses whose states were affected by Actions."""
  updatedAddresses: [Address]!
}

type TransferNCGHistoryType {
  amount: String!
  blockHash: ByteString!
  memo: String
  recipient: Address!
  sender: Address!
  txId: ByteString!
}

type Trie {
  """Gets the value stored at given key."""
  value(
    """The key to search."""
    key: KeyBytes!
  ): IValue

  """Gets the values stored at given multiple keys."""
  values(
    """The list of keys to search."""
    keys: [KeyBytes!]!
  ): IValue
}

scalar TxId

type TxResultType {
  """The block hash which the target transaction executed."""
  blockHash: String

  """The block index which the target transaction executed."""
  blockIndex: Long

  """The name of exception. (when only failed)"""
  exceptionNames: [String]

  """The input state's root hash which the target transaction executed."""
  inputState: HashDigest_SHA256

  """The output state's root hash which the target transaction executed."""
  outputState: HashDigest_SHA256

  """The transaction status."""
  txStatus: TxStatus!
}

enum TxStatus {
  FAILURE
  INCLUDED
  INVALID
  STAGING
  SUCCESS
}

type TxType {
  transaction: TransactionType!
  txResult: TxResultType
}

type ValidationQuery {
  metadata(
    """The raw value of json metadata."""
    raw: String!
  ): Boolean!
  privateKey(
    """The raw value of private-key, presented as hexadecimal."""
    hex: ByteString!
  ): Boolean!
  publicKey(
    """The raw value of public-key, presented as hexadecimal."""
    hex: ByteString!
  ): Boolean!
}

"""A data type holds validator's public key and its voting power."""
type Validator {
  """Gets the voting power of the validator."""
  power: BigInt!

  """The public key of the validator."""
  publicKey: PublicKey!
}

type Vote {
  """Hash of the block voted."""
  blockHash: String!

  """Flag of the vote"""
  flag: VoteFlag!

  """Height of the consensus voted."""
  height: Long!

  """Round of the consensus voted."""
  round: Int!

  """A digital signature of the content of this vote."""
  signature: ByteString!

  """The time this vote was created and signed."""
  timestamp: DateTimeOffset!

  """Power of the validator which is subject of the vote."""
  validatorPower: BigInt

  """Public key of the validator which is subject of the vote."""
  validatorPublicKey: PublicKey!
}

scalar VoteFlag

type WeeklyArenaStateType {
  address: Address!
  ended: Boolean!
  orderedArenaInfos: [ArenaInfoType]!
}

type WorldBossKillRewardRecordMapType {
  bossLevel: Int!

  """check reward already claimed. if already claimed return true."""
  claimed: Boolean!
}

type WorldBossKillRewardRecordType {
  map: [WorldBossKillRewardRecordMapType!]!
}

type WorldBossStateType {
  """world boss current hp."""
  currentHp: BigInt!

  """world boss season ended block index."""
  endedBlockIndex: Long!

  """world boss season id."""
  id: Int!

  """world boss current level."""
  level: Int!

  """world boss season started block index."""
  startedBlockIndex: Long!
}

type WorldInformationType {
  isStageCleared(stageId: Int!): Boolean!
  isWorldUnlocked(worldId: Int!): Boolean!
  lastClearedStage: ClearedStageType!
  world(worldId: Int!): WorldType!
}

type WorldState {
  """Gets the account associated with given address."""
  account(
    """The address of an account to retrieve."""
    address: Address!
  ): AccountState!

  """Gets the accounts associated with given addresses."""
  accounts(
    """The list of addresses of accounts to retrieve."""
    addresses: [Address!]!
  ): [AccountState!]!

  """Balance at given address and currency pair."""
  balance(
    """The address to look up."""
    address: Address!

    """The currency to look up."""
    currency: CurrencyInput!
  ): FungibleAssetValue!

  """The legacy flag of the world state."""
  legacy: Boolean!

  """The state root hash of the world state."""
  stateRootHash: HashDigestSHA256!

  """Total supply in circulation for given currency."""
  totalSupply(
    """The currency to look up."""
    currency: CurrencyInput!
  ): FungibleAssetValue!

  """The validator set."""
  validatorSet: IValue!

  """The version of the bakcing data model."""
  version: Int!
}

type WorldType {
  id: Int!
  isStageCleared: Boolean!
  isUnlocked: Boolean!
  name: String!
  stageBegin: Int!
  stageClearedBlockIndex: Long!
  stageClearedId: Int!
  stageEnd: Int!
  unlockedBlockIndex: Long!
}